<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PROLEAD: PROLEAD_public/inc/Util/Util.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PROLEAD<span id="projectnumber">&#160;3.0.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_696586db0b8a708c922c6867b383daee.html">PROLEAD_public</a></li><li class="navelem"><a class="el" href="dir_944cf9d86d30de3785def8d0e0087356.html">inc</a></li><li class="navelem"><a class="el" href="dir_69780d706d60b57dff1f4cb5156a7331.html">Util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Util.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;boost/math/distributions/chi_squared.hpp&gt;</code><br />
<code>#include &lt;boost/math/distributions/inverse_chi_squared.hpp&gt;</code><br />
<code>#include &lt;boost/math/distributions/non_central_chi_squared.hpp&gt;</code><br />
<code>#include &lt;boost/math/tools/roots.hpp&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;boost/generator_iterator.hpp&quot;</code><br />
<code>#include &quot;boost/random.hpp&quot;</code><br />
</div>
<p><a href="_util_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_table_entry.html">TableEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an entry in a contingency table, containing a key and associated data.  <a href="class_table_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contingency_table.html">ContingencyTable&lt; BucketContainer &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac788ca45210b614ed274901b57c0bff8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8hpp.html#ac788ca45210b614ed274901b57c0bff8">Key</a> = std::unique_ptr&lt; uint8_t[]&gt;</td></tr>
<tr class="memdesc:ac788ca45210b614ed274901b57c0bff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an observation set made by a set of probes.  <br /></td></tr>
<tr class="separator:ac788ca45210b614ed274901b57c0bff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24b1cdbc1ceea8e7aafb06d40060a05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8hpp.html#ad24b1cdbc1ceea8e7aafb06d40060a05">Data</a> = std::unique_ptr&lt; uint32_t[]&gt;</td></tr>
<tr class="memdesc:ad24b1cdbc1ceea8e7aafb06d40060a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a counter for each group, counting the occurrences of a particular key.  <br /></td></tr>
<tr class="separator:ad24b1cdbc1ceea8e7aafb06d40060a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8827d1651a0e84c7e646967537fd2c1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8hpp.html#a8827d1651a0e84c7e646967537fd2c1d">TableBucketVector</a> = std::vector&lt; <a class="el" href="class_table_entry.html">TableEntry</a> &gt;</td></tr>
<tr class="memdesc:a8827d1651a0e84c7e646967537fd2c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the contingency table as a sorted list of <a class="el" href="class_table_entry.html" title="Represents an entry in a contingency table, containing a key and associated data.">TableEntry</a> instances.  <br /></td></tr>
<tr class="separator:a8827d1651a0e84c7e646967537fd2c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8b4868ee62ffe6b478d33aa528f7e527"><td class="memTemplParams" colspan="2">template&lt;typename BucketContainer &gt; </td></tr>
<tr class="memitem:a8b4868ee62ffe6b478d33aa528f7e527"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8hpp.html#a8b4868ee62ffe6b478d33aa528f7e527">SortAndMergeDuplicates</a> (BucketContainer &amp;observations, uint64_t size_of_key_in_bytes, uint64_t number_of_groups)</td></tr>
<tr class="memdesc:a8b4868ee62ffe6b478d33aa528f7e527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in a bucket and merges duplicates.  <br /></td></tr>
<tr class="separator:a8b4868ee62ffe6b478d33aa528f7e527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b790cb67673b8135277f064fd745ed3"><td class="memTemplParams" colspan="2">template&lt;typename BucketContainer &gt; </td></tr>
<tr class="memitem:a2b790cb67673b8135277f064fd745ed3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_util_8hpp.html#a2b790cb67673b8135277f064fd745ed3">UpdateBucketWithBucket</a> (BucketContainer &amp;bucket, BucketContainer &amp;observations, uint64_t size_of_key_in_bytes, uint64_t number_of_groups)</td></tr>
<tr class="memdesc:a2b790cb67673b8135277f064fd745ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges elements from <code>observations</code> into <code>bucket</code>, updating existing entries and removing merged ones.  <br /></td></tr>
<tr class="separator:a2b790cb67673b8135277f064fd745ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e81c654202f1ed684e1548882290f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8hpp.html#ac6e81c654202f1ed684e1548882290f6">IsSampleSizeSufficient</a> (uint64_t number_of_samples, uint64_t number_of_groups, uint64_t number_of_entries, double_t beta_threshold, double_t effect_size)</td></tr>
<tr class="memdesc:ac6e81c654202f1ed684e1548882290f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the sample size is sufficient based on statistical parameters.  <br /></td></tr>
<tr class="separator:ac6e81c654202f1ed684e1548882290f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb98ef889ac04b8afbe0d9f3d060fe5b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8hpp.html#afb98ef889ac04b8afbe0d9f3d060fe5b">ComputeRequiredSampleSize</a> (uint64_t number_of_groups, uint64_t number_of_entries, double_t beta_threshold, double_t effect_size)</td></tr>
<tr class="memdesc:afb98ef889ac04b8afbe0d9f3d060fe5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the required sample size for a chi-squared test.  <br /></td></tr>
<tr class="separator:afb98ef889ac04b8afbe0d9f3d060fe5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ff7fee653135a3d4cbdc2b56bb0cba"><td class="memItemLeft" align="right" valign="top"><a id="a58ff7fee653135a3d4cbdc2b56bb0cba" name="a58ff7fee653135a3d4cbdc2b56bb0cba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>StartClock</b> (timespec &amp;start)</td></tr>
<tr class="separator:a58ff7fee653135a3d4cbdc2b56bb0cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfdda6a16da7885ac7ce18ae869d9ef"><td class="memItemLeft" align="right" valign="top"><a id="a9cfdda6a16da7885ac7ce18ae869d9ef" name="a9cfdda6a16da7885ac7ce18ae869d9ef"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>EndClock</b> (timespec &amp;start)</td></tr>
<tr class="separator:a9cfdda6a16da7885ac7ce18ae869d9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb79f326fd2460f592afa6639a1aa09"><td class="memItemLeft" align="right" valign="top"><a id="a7fb79f326fd2460f592afa6639a1aa09" name="a7fb79f326fd2460f592afa6639a1aa09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GenerateThreadRng</b> (std::vector&lt; boost::mt19937 &gt; &amp;rng, uint64_t number_of_threads)</td></tr>
<tr class="separator:a7fb79f326fd2460f592afa6639a1aa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a5ec1a95289bf716fd8dc6f17c2395"><td class="memItemLeft" align="right" valign="top"><a id="ac4a5ec1a95289bf716fd8dc6f17c2395" name="ac4a5ec1a95289bf716fd8dc6f17c2395"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractCombinationFromBitmask</b> (std::vector&lt; uint64_t &gt; &amp;combination, std::vector&lt; bool &gt; &amp;bitmask)</td></tr>
<tr class="separator:ac4a5ec1a95289bf716fd8dc6f17c2395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433f00194dd36f3ceca20ea93264036e"><td class="memItemLeft" align="right" valign="top"><a id="a433f00194dd36f3ceca20ea93264036e" name="a433f00194dd36f3ceca20ea93264036e"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>Util::PrintMemoryConsumption</b> ()</td></tr>
<tr class="separator:a433f00194dd36f3ceca20ea93264036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e835965c6d848d971f3ebdfb5f7d568"><td class="memItemLeft" align="right" valign="top"><a id="a3e835965c6d848d971f3ebdfb5f7d568" name="a3e835965c6d848d971f3ebdfb5f7d568"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Util::PrintHorizontalLine</b> (unsigned int width)</td></tr>
<tr class="separator:a3e835965c6d848d971f3ebdfb5f7d568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868610c3f8dfed6205e78ebdc1fc991d"><td class="memItemLeft" align="right" valign="top"><a id="a868610c3f8dfed6205e78ebdc1fc991d" name="a868610c3f8dfed6205e78ebdc1fc991d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Util::PrintRow</b> (std::vector&lt; unsigned int &gt; &amp;width, std::vector&lt; std::string &gt; &amp;elements)</td></tr>
<tr class="separator:a868610c3f8dfed6205e78ebdc1fc991d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63786acc69b1c839959b0ab4b9e7566a"><td class="memItemLeft" align="right" valign="top"><a id="a63786acc69b1c839959b0ab4b9e7566a" name="a63786acc69b1c839959b0ab4b9e7566a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Util::GenerateThreadRng</b> (std::vector&lt; boost::mt19937 &gt; &amp;, unsigned int)</td></tr>
<tr class="separator:a63786acc69b1c839959b0ab4b9e7566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbcbf96e3edc9f92e4924387f7c8366"><td class="memItemLeft" align="right" valign="top"><a id="a3cbcbf96e3edc9f92e4924387f7c8366" name="a3cbcbf96e3edc9f92e4924387f7c8366"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Util::ExtractCombinationFromBitmask</b> (std::vector&lt; unsigned int &gt; &amp;combination, std::vector&lt; bool &gt; &amp;bitmask)</td></tr>
<tr class="separator:a3cbcbf96e3edc9f92e4924387f7c8366"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Felix Uhle </dd>
<dd>
Nicolai MÃ¼ller </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad24b1cdbc1ceea8e7aafb06d40060a05" name="ad24b1cdbc1ceea8e7aafb06d40060a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24b1cdbc1ceea8e7aafb06d40060a05">&#9670;&#160;</a></span>Data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="_util_8hpp.html#ad24b1cdbc1ceea8e7aafb06d40060a05">Data</a> =  std::unique_ptr&lt;uint32_t[]&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a counter for each group, counting the occurrences of a particular key. </p>
<p>The <code>Data</code> type is used to maintain a count of the number of times a specific key appears in each group. To minimize memory overhead, dynamically allocated arrays are used instead of vectors. Specifically, there is no need to store the size of the array since the size is determined by the number of groups. </p>

</div>
</div>
<a id="ac788ca45210b614ed274901b57c0bff8" name="ac788ca45210b614ed274901b57c0bff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac788ca45210b614ed274901b57c0bff8">&#9670;&#160;</a></span>Key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="_util_8hpp.html#ac788ca45210b614ed274901b57c0bff8">Key</a> =  std::unique_ptr&lt;uint8_t[]&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents an observation set made by a set of probes. </p>
<p>The <code>Key</code> type is used to identify a particular observation in the contingency table. To minimize memory overhead, dynamically allocated arrays are used instead of vectors. Specifically, there is no need to store the size of the array since the size is determined by the maximum number of probe-extensions. </p>

</div>
</div>
<a id="a8827d1651a0e84c7e646967537fd2c1d" name="a8827d1651a0e84c7e646967537fd2c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8827d1651a0e84c7e646967537fd2c1d">&#9670;&#160;</a></span>TableBucketVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="_util_8hpp.html#a8827d1651a0e84c7e646967537fd2c1d">TableBucketVector</a> =  std::vector&lt;<a class="el" href="class_table_entry.html">TableEntry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the contingency table as a sorted list of <a class="el" href="class_table_entry.html" title="Represents an entry in a contingency table, containing a key and associated data.">TableEntry</a> instances. </p>
<p>The <code>TableBucketVector</code> type is used to maintain the contingency table as a sorted list of <code><a class="el" href="class_table_entry.html" title="Represents an entry in a contingency table, containing a key and associated data.">TableEntry</a></code> objects. A <code>std::vector</code> is chosen for its relatively low memory overhead, ease of sorting, and ability to dynamically extend.</p>
<p><code>TableBucketVector</code> is the currently implemented data type used for the <code>BucketContainer</code> template. Users are encouraged to implement and experiment with other data structures that might offer better performance or characteristics. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afb98ef889ac04b8afbe0d9f3d060fe5b" name="afb98ef889ac04b8afbe0d9f3d060fe5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb98ef889ac04b8afbe0d9f3d060fe5b">&#9670;&#160;</a></span>ComputeRequiredSampleSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ComputeRequiredSampleSize </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number_of_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number_of_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_t&#160;</td>
          <td class="paramname"><em>beta_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_t&#160;</td>
          <td class="paramname"><em>effect_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the required sample size for a chi-squared test. </p>
<p>This function calculates the sample size needed to achieve sufficient statistical power in a chi-squared test based on specified parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_groups</td><td>The number of groups in the dataset. </td></tr>
    <tr><td class="paramname">number_of_entries</td><td>The number of entries in the dataset. </td></tr>
    <tr><td class="paramname">beta_threshold</td><td>The desired probability of a Type II error (false-negative rate). </td></tr>
    <tr><td class="paramname">effect_size</td><td>The desired effect size to detect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed required sample size to achieve the desired statistical power. </dd></dl>

</div>
</div>
<a id="ac6e81c654202f1ed684e1548882290f6" name="ac6e81c654202f1ed684e1548882290f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e81c654202f1ed684e1548882290f6">&#9670;&#160;</a></span>IsSampleSizeSufficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsSampleSizeSufficient </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number_of_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number_of_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number_of_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_t&#160;</td>
          <td class="paramname"><em>beta_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_t&#160;</td>
          <td class="paramname"><em>effect_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the sample size is sufficient based on statistical parameters. </p>
<p>This function calculates whether the given sample size is adequate for detecting an effect size with a specified beta threshold, given the number of groups and entries. It uses a chi-squared distribution to compute the critical value and a non-central chi-squared distribution to evaluate the cumulative distribution function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_samples</td><td>The number of samples in the dataset. </td></tr>
    <tr><td class="paramname">number_of_groups</td><td>The number of groups in the dataset. </td></tr>
    <tr><td class="paramname">number_of_entries</td><td>The number of entries in the dataset. </td></tr>
    <tr><td class="paramname">beta_threshold</td><td>The acceptable probability of a Type II error (false-negative rate). </td></tr>
    <tr><td class="paramname">effect_size</td><td>The expected effect size to detect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sample size is sufficient to detect the effect size with the given beta threshold, false otherwise. </dd></dl>

</div>
</div>
<a id="a8b4868ee62ffe6b478d33aa528f7e527" name="a8b4868ee62ffe6b478d33aa528f7e527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4868ee62ffe6b478d33aa528f7e527">&#9670;&#160;</a></span>SortAndMergeDuplicates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BucketContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SortAndMergeDuplicates </td>
          <td>(</td>
          <td class="paramtype">BucketContainer &amp;&#160;</td>
          <td class="paramname"><em>observations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size_of_key_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number_of_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in a bucket and merges duplicates. </p>
<p>Sorts the entries in the <code>TableBucketVector</code> based on their keys and merges duplicate entries by summing their counters. This ensures that each key in the vector is unique, with the corresponding counter representing the total count of occurrences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observations</td><td>The bucket (vector) to sort and merge. </td></tr>
    <tr><td class="paramname">size_of_key_in_bytes</td><td>The size of the keys in bytes, used for comparing keys. </td></tr>
    <tr><td class="paramname">number_of_groups</td><td>The number of groups, used to determine the length of the <code>Data</code> array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b790cb67673b8135277f064fd745ed3" name="a2b790cb67673b8135277f064fd745ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b790cb67673b8135277f064fd745ed3">&#9670;&#160;</a></span>UpdateBucketWithBucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BucketContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UpdateBucketWithBucket </td>
          <td>(</td>
          <td class="paramtype">BucketContainer &amp;&#160;</td>
          <td class="paramname"><em>bucket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BucketContainer &amp;&#160;</td>
          <td class="paramname"><em>observations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size_of_key_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number_of_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges elements from <code>observations</code> into <code>bucket</code>, updating existing entries and removing merged ones. </p>
<p>Iterates through the <code>observations</code> and <code>bucket</code> vectors. If an element in <code>observations</code> is already present in <code>bucket</code>, it updates the corresponding element in <code>bucket</code> and removes the element from <code>observations</code>. If the element is not present in <code>bucket</code>, it is retained in <code>observations</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket</td><td>The vector representing the bucket where data is merged. </td></tr>
    <tr><td class="paramname">observations</td><td>The vector containing observations to merge into the bucket. Elements that are merged will be removed. </td></tr>
    <tr><td class="paramname">size_of_key_in_bytes</td><td>The size of the key in bytes used for comparison. </td></tr>
    <tr><td class="paramname">number_of_groups</td><td>The number of groups of data associated with each key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
