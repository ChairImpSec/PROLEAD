#pragma once
#ifndef PROBING_HPP
#define PROBING_HPP
#include "Software/Definitions.hpp"
#include "Software/mulator/emulator.h"
#include "Software/Operators.hpp"
#include <algorithm>
#include <cmath>
#include <numeric>

#define ID_OFFSET 23
#define ID_MASK 0x7800000
#define REG1_OFFSET 18
#define REG1_MASK 0x7c0000
#define REG2_OFFSET 13
#define REG2_MASK 0x3e000
#define BIT_OFFSET 8
#define BIT_MASK 0x1f00
#define CYCLE_OFFSET 32
#define EXTENSION_MASK 0xff
#define DEPENDENCY_OFFSET 27
#define DEPENDENCY_MASK 0x78000000

namespace Software
{
    namespace Probing
    {
        /**
         * @brief Generate probing sets from single probes, does it for any order and univariate and multivariate
         * 
         * @param ThreadSimulation thread simulation struct to get the probes from
         * @param Settings The general settings, i.e. parameters for statistical power analysis.
         * @param Test The test settings, i.e. the unique probes and the contingency tables.
         * @param OrderOverTwoCombination all pairwise combintions of possible probes
         * @param ProbeInfoToStandardProbe mapping between probes generated by prolead and resolved standard probes
         * @param SimulationIndex current simulation number
         */
        void GetProbingSets(Software::ThreadSimulationStruct& ThreadSimulation, SettingsStruct& Settings, Software::TestStruct& Test, std::vector<std::tuple<uint32_t, uint32_t>>& OrderOverTwoCombination, std::vector<std::vector<uint32_t>>& ProbeInfoToStandardProbe, uint64_t SimulationIndex);
        
        /**
         * @brief Get the Multivariate Probing Sets object
         * 
         * @param OneSimulationStandardProbes standard probes of one full simulation
         * @param Settings The general settings, i.e. parameters for statistical power analysis.
         * @param Test The test settings, i.e. the unique probes and the contingency tables.
         * @param OrderOverTwoCombination all pairwise combintions of possible probes
         * @param ProbeInfoToStandardProbe mapping between probes generated by prolead and resolved standard probes
         * @param ThreadIndex thread number
         * @param SimulationIndex current simulation number
         */
        void GetMultivariateProbingSets(std::vector<std::vector<Software::ProbesStruct>>& OneSimulationStandardProbes, SettingsStruct& Settings, Software::TestStruct& Test, std::vector<std::tuple<uint32_t, uint32_t>>& OrderOverTwoCombination, std::vector<std::vector<uint32_t>>& ProbeInfoToStandardProbe, uint32_t ThreadIndex, uint32_t SimulationIndex);
        
        /**
         * @brief 
         * 
         * @param Settings The general settings, i.e. parameters for statistical power analysis.
         * @param ProbingSet probing set, consisting of d probes
         * @return true 
         * @return false 
         */
        bool InDistance(Software::SettingsStruct& Settings, std::vector<Software::ProbesStruct>& ProbingSet);

        /**
         * @brief Create a Normal Probe object
         * 
         * @param NormalProbesRegister list of bit indices that will be probed for this register
         * @param StandardProbes list of generated probes 
         * @param ProbeValueRegister list to store probed values of probed register in this probed cycle
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param RegisterTransitionCycle transition cycle of register
         * @param InstrNr instruction number when probe was generated
         * @param SimulationIdx current simulation number
         * @param DestinationRegisterValue value of probed destination register
         * @param RegNr Number of Register that is probed
         */
        void CreateNormalProbe(std::vector<uint8_t>& NormalProbesRegister, std::vector<Software::ProbesStruct>& StandardProbes, std::vector<std::vector<uint8_t>>& ProbeValueRegister, uint32_t& ProbeIndex, uint64_t& ProbeInfo, uint32_t RegisterTransitionCycle, uint32_t InstrNr, uint64_t SimulationIdx, uint32_t DestinationRegisterValue, uint8_t RegNr);
        
        /**
         * @brief Create a Horizontal Probe 
         * 
         * @param StandardProbes list of generated probes 
         * @param RegisterTransitionCycle transition cycle of register
         * @param ExtensionSize How many standard probes will be created when resolving the probe
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param InstrNr instruction number when probe was generated
         * @param RegisterNumber Number of Register that is probed
         */
        void CreateHorizontalProbe(std::vector<Software::ProbesStruct>& StandardProbes, uint32_t RegisterTransitionCycle, uint8_t ExtensionSize, uint32_t& ProbeIndex, uint32_t InstrNr, uint8_t RegisterNumber);

        /**
         * @brief Create a Large Vertical Probe 
         * 
         * @param StandardProbes list of generated probes 
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param TransCycleRegNr transition cycle of register
         * @param TransCyclePartnerRegNr transition cycle of partner register
         */
        void CreateLargeVerticalProbe(std::vector<Software::ProbesStruct>& StandardProbes, uint64_t& ProbeInfo , uint32_t& ProbeIndex, uint32_t TransCycleRegNr, uint32_t TransCyclePartnerRegNr);
        
        /**
         * @brief Create a Small Vertical Probe 
         * 
         * @param StandardProbes list of generated probes 
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param TransCycleRegNr transition cycle of register
         * @param CyclePartnerRegNr cycle of partner register
         */
        void CreateSmallVerticalProbe(std::vector<Software::ProbesStruct>& StandardProbes, uint64_t& ProbeInfo , uint32_t& ProbeIndex, uint32_t TransCycleRegNr, uint32_t CyclePartnerRegNr);
        
        /**
         * @brief Create a Large Full Horizontal Probe 
         * 
         * @param StandardProbes list of generated probes 
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param TransCycleRegNr transition cycle of register
         * @param TransCyclePartnerRegNr transition cycle of partner register
         */
        void CreateLargeFullHorizontalProbe(std::vector<Software::ProbesStruct>& StandardProbes, uint64_t& ProbeInfo , uint32_t& ProbeIndex, uint32_t TransCycleRegNr, uint32_t TransCyclePartnerRegNr);
        
        /**
         * @brief Create a Small Full Horizontal Probe 
         * 
         * @param StandardProbes list of generated probes 
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param TransCycleRegNr transition cycle of register
         * @param CyclePartnerRegNr cycle of partner register
         */
        void CreateSmallFullHorizontalProbe(std::vector<Software::ProbesStruct>& StandardProbes, uint64_t& ProbeInfo , uint32_t& ProbeIndex, uint32_t TransCycleRegNr, uint32_t CyclePartnerRegNr);
        
        /**
         * @brief Create a Large Full Vertical Probe 
         * 
         * @param StandardProbes list of generated probes 
         * @param FullVerticalProbes all register indices that are used in the probe
         * @param BitIdx bit index of probed register
         * @param RegNr Number of Register that is probed
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param RegisterValues values of all probed registers for this probe
         * @param TransValueRegNr old value of register
         * @param TransValuePC old value of PC
         * @param TransValuePSR old value of PSR
         */
        void CreateLargeFullVerticalProbe(std::vector<Software::ProbesStruct>& StandardProbes, std::vector<uint8_t>& FullVerticalProbes, uint8_t BitIdx, uint8_t RegNr, uint32_t& ProbeIndex, uint64_t ProbeInfo, std::vector<uint32_t>& RegisterValues, uint32_t TransValueRegNr, uint32_t TransValuePC, uint32_t TransValuePSR);
        
        /**
         * @brief Create a Small Full Vertical Probe object
         * 
         * @param StandardProbes list of generated probes 
         * @param FullVerticalProbes all register indices that are used in the probe
         * @param BitIdx bit index of probed register
         * @param RegNr1 Number of Register that is probed
         * @param RegNr2 Number of Register that is probed
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param RegisterValues values of all probed registers for this probe
         * @param TransValueReg1 old value of first register
         * @param TransValueReg2 old value of second register
         */
        void CreateSmallFullVerticalProbe(std::vector<Software::ProbesStruct>& StandardProbes, std::vector<uint8_t>& FullVerticalProbes, uint8_t BitIdx, uint8_t RegNr1, uint8_t RegNr2, uint32_t& ProbeIndex, uint64_t ProbeInfo, std::vector<uint32_t>& RegisterValues, uint32_t TransValueReg1, uint32_t TransValueReg2);
        
        /**
         * @brief Create a One Register Only Full Vertical Probe object
         * 
         * @param StandardProbes list of generated probes 
         * @param FullVerticalProbes all register indices that are used in the probe
         * @param BitIdx bit index of probed register
         * @param RegNr1 Number of Register that is probed
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param RegisterValues values of all probed registers for this probe
         * @param TransValueRegNr old value of register
         */
        void CreateOneRegisterOnlyFullVerticalProbe(std::vector<Software::ProbesStruct>& StandardProbes, std::vector<uint8_t>& FullVerticalProbes, uint8_t BitIdx, uint8_t RegNr1, uint32_t& ProbeIndex, uint64_t ProbeInfo, std::vector<uint32_t>& RegisterValues, uint32_t TransValueRegNr);

        /**
         * @brief 
         * 
         * @param StandardProbes list of generated probes 
         * @param FullVerticalProbes all register indices that are used in the probe
         * @param BitIdx bit index of probed register
         * @param low_RegNr lower register number of dsp instruction
         * @param high_RegNr higher register number of dsp instruction
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param RegisterValues values of all probed registers for this probe
         * @param TransValueLowRegNr old value of lower register
         * @param TransValueHighRegNr old value of higher register
         * @param TransValuePC old value of pc register
         * @param TransValuePSR old value of psr register
         */
        void CreateDSPLargeFullVerticalProbe(std::vector<Software::ProbesStruct>& StandardProbes, std::vector<uint8_t>& FullVerticalProbes, uint8_t BitIdx, uint8_t low_RegNr, uint8_t high_RegNr, uint32_t& ProbeIndex, uint64_t ProbeInfo, std::vector<uint32_t>& RegisterValues, uint32_t TransValueLowRegNr, uint32_t TransValueHighRegNr, uint32_t TransValuePC, uint32_t TransValuePSR);
        
        /**
         * @brief Create a
         * 
         * @param StandardProbes list of generated probes 
         * @param FullVerticalProbes all register indices that are used in the probe
         * @param BitIdx bit index of probed register
         * @param low_RegNr lower register number of dsp instruction
         * @param high_RegNr higher register number of dsp instruction
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param RegisterValues values of all probed registers for this probe
         * @param TransValueLowRegNr old value of lower register
         * @param TransValueHighRegNr old value of higher register
         * @param TransValuePC old value of pc register
         */
        void CreateDSPSmallFullVerticalProbe(std::vector<Software::ProbesStruct>& StandardProbes, std::vector<uint8_t>& FullVerticalProbes, uint8_t BitIdx, uint8_t low_RegNr, uint8_t high_RegNr, uint32_t& ProbeIndex, uint64_t ProbeInfo, std::vector<uint32_t>& RegisterValues, uint32_t TransValueLowRegNr, uint32_t TransValueHighRegNr, uint32_t TransValuePC);
        
        void CreateMemoryProbe();

        /**
         * @brief Create a Mem Shadow Probe probe
         * 
         * @param StandardProbes list of generated probes 
         * @param MemoryShadowRegisterProbesIncluded bits that are considered when probing memory shadow register
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param memory_shadow_register old value of memory shadow register
         * @param next_shadow_register_value new value of memory shadow register
         * @param TransitionCycle transition cycle of register
         */
        void CreateMemShadowProbe(std::vector<Software::ProbesStruct>& StandardProbes, std::vector<uint8_t>& MemoryShadowRegisterProbesIncluded,  uint64_t ProbeInfo, uint32_t& ProbeIndex, uint32_t memory_shadow_register, uint32_t next_shadow_register_value, uint32_t TransitionCycle);
        
        /**
         * @brief Create a Seperate Load Store Mem Shadow Probe probe
         * 
         * @param StandardProbes list of generated probes 
         * @param MemoryShadowRegisterProbesIncluded bits that are considered when probing memory shadow register
         * @param RegNr register number if multiple probes in one instructions are generated to ensure sorted order
         * @param InstrNr instruction number when probe was generated
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param load_store_memory_shadow_register old value of load/store memory shadow register
         * @param next_load_store_shadow_register_value new value of load/store memory shadow register
         * @param TransitionCycle transition cycle of memory shadow register
         * @param ExtensionSize How many standard probes will be created when resolving the probe
         * @param LoadStoreFlag Decide memory register is for load or store operation
         */
        void CreateSeperateLoadStoreMemShadowProbe(std::vector<Software::ProbesStruct>& StandardProbes, std::vector<uint8_t>& MemoryShadowRegisterProbesIncluded, uint32_t RegNr, uint32_t InstrNr, uint32_t& ProbeIndex, uint32_t load_store_memory_shadow_register, uint32_t next_load_store_shadow_register_value, uint32_t TransitionCycle, uint32_t ExtensionSize, uint32_t LoadStoreFlag);
        
        /**
         * @brief Create a Horizontal Mem Shadow Probe probe
         * 
         * @param StandardProbes list of generated probes 
         * @param InstrNr instruction number when probe was generated
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param RegNr register number if multiple probes in one instructions are generated to ensure sorted order
         * @param memory_shadow_register old value of memory shadow register
         * @param next_shadow_register_value new value of memory shadow register
         * @param TransitionCycle transition cycle of register
         * @param ExtensionSize How many standard probes will be created when resolving the probe
         */
        void CreateHorizontalMemShadowProbe(std::vector<Software::ProbesStruct>& StandardProbes, uint32_t InstrNr, uint32_t& ProbeIndex, uint8_t RegNr, uint32_t memory_shadow_register, uint32_t next_shadow_register_value, uint32_t TransitionCycle, uint32_t ExtensionSize);

        /**
         * @brief Create a Pipeline Forwarding Probe probe
         * 
         * @param StandardProbes list of generated probes 
         * @param PipelineForwardingProbes 
         * @param BitIdx bit index for pipeline forwarding probe (i-th bit of registers)
         * @param ProbeIndex index of probe in list of standard probes where new probe will be inserted
         * @param ProbeInfo probe information of ProbesStruct that will be filled
         * @param NrOfPipelineStages number of pipeline stages
         * @param pipeline_cpu_states cpu states of last #NrOfPipelineStages cycles
         */
        void CreatePipelineForwardingProbe(std::vector<Software::ProbesStruct>& StandardProbes, std::vector<uint8_t>& PipelineForwardingProbes, uint8_t BitIdx, uint32_t& ProbeIndex, uint64_t ProbeInfo, uint32_t NrOfPipelineStages, std::vector<::mulator::CPU_State>& pipeline_cpu_states);

        /**
         * @brief extract all informations from probe info
         * 
         * @param Register register information of probe
         * @param Id id information of probe
         * @param PartnerRegister partner register information of probe
         * @param Cycle cycle information of probe
         * @param Bit bit information of probe
         * @param ExtensionSize How many standard probes will be created when resolving the probe
         * @param Dependency dependency information of probe
         * @param ProbeFromProbingSet probe to extract the dependency information
         */
        void ExtractAllProbeInfo(uint8_t& Register, uint8_t& Id, uint8_t& PartnerRegister, uint32_t& Cycle, uint8_t& Bit, uint16_t& ExtensionSize, uint8_t& Dependency, Software::ProbesStruct& ProbeFromProbingSet);
        
        /**
         * @brief extract bit index from probe info
         * 
         * @param Bit bit information of probe
         * @param ProbeFromProbingSet probe to extract the dependency information
         */
        void ExtractBitProbeInfo(uint8_t& Bit, Software::ProbesStruct& ProbeFromProbingSet);
        
        /**
         * @brief extract cycle from probe info
         * 
         * @param Cycle cycle information of probe
         * @param ProbeFromProbingSet probe to extract the dependency information
         */
        void ExtractCycleProbeInfo(uint32_t& Cycle, Software::ProbesStruct& ProbeFromProbingSet);
        
        /**
         * @brief extract id from probe info
         * 
         * @param Id id information of probe
         * @param ProbeFromProbingSet probe to extract the dependency information
         */
        void ExtractIdProbeInfo(uint8_t& Id, Software::ProbesStruct& ProbeFromProbingSet);
        
        /**
         * @brief extract register from probe info
         * 
         * @param Register register information of probe
         * @param ProbeFromProbingSet probe to extract the register information
         */
        void ExtractRegisterProbeInfo(uint8_t& Register, Software::ProbesStruct& ProbeFromProbingSet);
        
        /**
         * @brief Extract the dependency from probe info
         * 
         * @param Dependency dependency information of probe
         * @param ProbeFromProbingSet probe to extract the dependency information
         */
        void ExtractDependencyProbeInfo(uint8_t& Dependency, Software::ProbesStruct& ProbeFromProbingSet);
        
        /**
         * @brief Extract the extension size from probe info
         * 
         * @param ExtensionSize extension size information of probe
         * @param ProbeFromProbingSet probe to extract the dependency information
         */
        void ExtractExtensionSizeProbeInfo(uint16_t& ExtensionSize, Software::ProbesStruct& ProbeFromProbingSet);

        void FillHigherOrderRedundantCases(std::vector<std::vector<uint32_t>>&);
        void RedundancyNormalProbe(std::vector<std::vector<uint32_t>>&);
        void RedundancyHorizontalProbe(std::vector<std::vector<uint32_t>>&);
        void RedundancyVerticalProbe(std::vector<std::vector<uint32_t>>&);
        void RedundancyFullHorizontalProbe(std::vector<std::vector<uint32_t>>&);
        void RedundancyFullVerticalProbe(std::vector<std::vector<uint32_t>>&);
        
        /**
         * @brief 
         * 
         * @param ProbeMapping mapping between probes generated by prolead and resolved standard probes
         * @param Helper helper struct that track meta information for probes
         * @param Setting settings regarding simulations
         */
        void ProbeInfoToStandardProbeMapping(std::vector<std::vector<uint32_t>>& ProbeMapping, Software::HelperStruct& Helper, Software::SettingsStruct& Setting);
        
        /**
         * @brief 
         * 
         * @param ProbingSet probing set that will be filled with d probes
         * @param Combination combinations of d probes
         * @param OrderOverTwoCombination all pairwise combintions of possible probes
         * @param ProbeMapping mapping between probes generated by prolead and resolved standard probes
         * @param ResolvedProbes resolved standard probes from generated probes
         * @param TestOrder The security order to test.
         */
        void Univariate_AddCombinationToProbingSet(Software::ProbingSetStruct& ProbingSet, std::vector<Software::ProbesStruct>& Combination, std::vector<std::tuple<uint32_t, uint32_t>>& OrderOverTwoCombination, std::vector<std::vector<uint32_t>>& ProbeMapping, std::vector<std::vector<uint32_t>>& ResolvedProbes, uint32_t TestOrder);
        
        /**
         * @brief 
         * 
         * @param ProbingSet probing set that will be filled with d probes
         * @param Combination combinations of d probes
         * @param OrderOverTwoCombination all pairwise combintions of possible probes
         * @param ProbeMapping mapping between probes generated by prolead and resolved standard probes
         * @param ResolvedProbes resolved standard probes from generated probes
         * @param TestOrder The security order to test.
         */
        void Multivariate_AddCombinationToProbingSet(Software::ProbingSetStruct& ProbingSet, std::vector<Software::ProbesStruct>& Combination, std::vector<std::tuple<uint32_t, uint32_t>>& OrderOverTwoCombination, std::vector<std::vector<uint32_t>>& ProbeMapping, std::vector<std::vector<uint32_t>>& ResolvedProbes, uint32_t TestOrder);
    } // namespace Probing
    
    
} // namespace Software

#endif